---
export const prerender = true; // Enable SSR but allow client-side execution where needed
---

<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta
            content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
            name="viewport"
    />
    <meta content="ie=edge" http-equiv="X-UA-Compatible" />
    <title>Images test with Lazy Loading & Skeleton Loading</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            padding: 20px;
        }

        .gallery-wrapper {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            row-gap: 20px;
            column-gap: 20px;
        }

        @media screen and (max-width: 480px) {
            .gallery-wrapper {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                grid-template-rows: repeat(auto-fit, minmax(400px, 1fr));
            }
        }

        .lazy-loaded {
            opacity: 1;
        }

        /* Skeleton Loader Styles */
        .skeleton {
            height: 450px;
            width: 100%;
            background-color: #ddd;
            position: relative;
            overflow: hidden;
            border: 2px solid red; /* For easy visibility during debugging */
        }

        .skeleton::after {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            height: 100%;
            width: 100%;
            background: linear-gradient(
                    90deg,
                    rgba(255, 255, 255, 0) 0%,
                    rgba(255, 255, 255, 0.5) 50%,
                    rgba(255, 255, 255, 0) 100%
            );
            animation: skeleton-loading 1.5s infinite;
        }

        @keyframes skeleton-loading {
            0% {
                left: -100%;
            }
            50% {
                left: 100%;
            }
            100% {
                left: -100%;
            }
        }

        img {
            display: block;
            max-width: 100%;
            height: auto;
        }

        .hidden {
            opacity: 0;
            transition: opacity 0.5s ease-in;
        }

        .visible {
            opacity: 1;
        }
    </style>
</head>
<body>
<div class="gallery-wrapper"></div>

<script>
    // Create and return an img element with a skeleton loader in place
    function createImageElement(src, alt) {
        const imgContainer = document.createElement('div');
        imgContainer.classList.add('skeleton'); // Add skeleton class for placeholder animation

        const img = document.createElement('img');
        img.dataset.src = src; // Set the image source in data-src for lazy loading
        img.alt = alt;
        img.classList.add('hidden'); // Keep the image hidden initially
        img.style.minHeight = '100%';
        img.style.width = '100%';
        img.style.objectFit = 'cover';
        img.style.objectPosition = 'center';

        // Add error handling for images that fail to load
        img.onerror = () => {
            console.error(`Failed to load image: ${src}`);
            imgContainer.remove(); // Optionally remove the container if the image fails to load
        };

        // Append the image into the container
        imgContainer.appendChild(img);

        return imgContainer; // Return container with the image inside
    }

    // Lazy load images using IntersectionObserver
    function lazyLoadImages() {
        const images = document.querySelectorAll('img[data-src]'); // Select all images to observe
        const options = {
            root: null,
            rootMargin: '100px', // Start loading earlier when images are 100px away from the viewport
            threshold: 0.01 // Load image when 1% of it is visible
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                const img = entry.target;

                if (entry.isIntersecting && !img.classList.contains('visible')) { // Only load if not yet visible
                    const container = img.parentElement;

                    // Set the actual image source and handle loading
                    img.src = img.dataset.src;
                    img.onload = () => {
                        img.classList.add('visible'); // Make the image visible
                        img.classList.remove('hidden'); // Remove the hidden class
                        container.classList.remove('skeleton'); // Remove skeleton loader
                        container.style.border = 'none'; // Remove border after loading
                    };
                }
            });
        }, options);

        images.forEach(img => observer.observe(img)); // Observe each image
    }

    // Generate image tags with skeleton loaders
    function generateImageTags() {
        const imagesContainer = document.querySelector(".gallery-wrapper");
        for (let i = 1; i <= 33; i++) {
            const imageUrl = `https://dyvkdbmmzvclydrmokpq.supabase.co/storage/v1/object/public/portraits/${i}.webp`;
            const imgElement = createImageElement(imageUrl, `Image ${i}`);
            imagesContainer.appendChild(imgElement);
        }

        lazyLoadImages(); // Call lazy load function after generating images
    }

    document.addEventListener('DOMContentLoaded', () => {
        generateImageTags(); // Run the function to generate and lazy-load images after DOM is ready
    });
</script>
</body>
</html>
